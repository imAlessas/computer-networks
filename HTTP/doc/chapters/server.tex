\section{Server}

\begin{lstlisting}
#include <stdio.h>  // printf, perror, fopen, fread, feof, fclose
#include <string.h> // strlen
#include <stdlib.h> // exit
#include <unistd.h> // read, write, fork
#include <sys/socket.h> // socket, bind, listen, accept
#include <arpa/inet.h>  // htons, sockaddr, sockaddr_in


// constants
#define PORT 31415
#define BUFFER_SIZE 1024



struct char_map {
    char * key;
    char * value;
};



int main() {

    // local variables
    int s, s_double;                                    // sockets
    char * command_line;                                // first line of request
    struct char_map headers[100] =  {{NULL, NULL}};     // headers
    char header_buffer[BUFFER_SIZE] = {0};              // header buffer, here there will be all the info from the header
    char response_buffer[BUFFER_SIZE] = {0};            // response buffer, will be used to temporarily store the response
    char * method, * uri, * version;                    // parsed values from command_line
    int i, yes = 1;                                              // generic index

    // define address
    struct sockaddr_in server_address;
    struct sockaddr_in client_address;





    // socket
    s = socket( AF_INET, SOCK_STREAM, 0);

    // terminate if error
    if( s == -1 ) {
        perror("socket() failed");
        return 1;
    }


    if ( -1 == setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) ) {
        perror("setsockopt() failed");
        return 1;
    }
    
    // define address
    server_address.sin_family      = AF_INET;
    server_address.sin_port        = htons(PORT);
    server_address.sin_addr.s_addr = 0;

    // bind
    if( -1 == bind(s, (struct sockaddr *) &server_address, sizeof(struct sockaddr_in)) ) {
        perror("bind() failed");
        return 1;
    }

    // listen
    if( -1 == listen(s, 5) ) {
        perror("listen() failed");
        return 1;
    }


    int sockaddr_size = sizeof(struct sockaddr);

    while(1) {
        
        // accept
        s_double = accept(s, (struct sockaddr *) &client_address, &sockaddr_size);


        // create sub-process
        if (fork()) {
            close(s_double);
            continue;
        }

        // terminate if error
        if( s_double == -1 ) {
            perror("accept() failed");
            return 1;
        }


        // parse the header
        command_line = headers[0].key = header_buffer;
        int lines = 0;

        for(i = 0; read(s_double, header_buffer + i, 1); i++) {

            // end of the line
            if(header_buffer[i - 1] == '\r' && header_buffer[i] == '\n') {
                
                // null-terminate
                header_buffer[i - 1] = 0;

                // check if it is the end
                if( !headers[lines].key[0] )
                    break;

                // create new line on the headers
                lines++;
                headers[lines].key = &header_buffer[i + 1];
            }

            if( header_buffer[i] == ':' && (headers[lines].value == NULL)) {
                
                // start value
                headers[lines].value = &header_buffer[i + 1] + 1;

                // null-terminate
                header_buffer[i] = 0;

            }
        }

        // print headers
        for(i = 0; i < lines; i++)
            printf("%s ----> %s\n", headers[i].key, headers[i].value);
        

        // parse method, uri, version
        method = command_line;
        for(i = 0; command_line[i] != ' '; i++);
        command_line[i++] = 0;

        uri = command_line + i;
        for(; command_line[i] != ' '; i++);
        command_line[i++] = 0;

        version = command_line + i;
        for(; command_line[i] != 0; i++);
        command_line[i++] = 0;

        // print values
        printf("Method ----> %s\nURI ----> %s\nVersion ----> %s\n", method, uri, version);


        // opens file
        FILE * file = fopen(uri + 1, "rw");

        if( file == NULL ) {
            
            // create 404 response
            sprintf(response_buffer, "HTTP/1.1 404 NOT FOUND\r\n\r\n<html><h1>File %s was not found.</h1></html>", uri);
            
            // send response
            if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
                perror("write() failed");
                return 1;
            }

        } else {
            


            // send accept header
            sprintf(response_buffer, "HTTP/1.1 200 OK\r\n\r\n");

            if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
                perror("write() failed");
                return 1;
            }

            // read and send the file
            while( !feof(file) ) {
                
                // read 1Kb from the file
                fread(response_buffer, 1, 1024, file);

                // write the answer
                if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
                    perror("write() failed");
                    return 1;
                }

                for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

            }

            fclose(file);

        }

        
        printf("\n\n\n");

        // close socket and kill process
        close(s_double);
        exit(1);

    }

    return 0;

} // main

\end{lstlisting}

\newpage\subsection{Content-Length}

\begin{lstlisting}
    content_length = 0;

    // get content length of the file
    while( fgetc(file) != EOF )
        content_length++;

    printf("Content-Length: %d\n\n\n", content_length);


    // send accept header
    sprintf(response_buffer, "HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n", content_length);

    if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
        perror("write() failed");
        return 1;
    }

    // reset buffer
    for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;



    // pointer to the beginning
    rewind(file);

    // read and send the file
    while( !feof(file) ) {
        
        // read 1Kb from the file
        fread(response_buffer, 1, 1024, file);

        // write the answer
        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

    }

    fclose(file);
\end{lstlisting}


\newpage\subsection{Reflect}

\begin{lstlisting}
    // process the `/reflect` request
    if ( !strncmp(uri, "/reflect", strlen("/reflect")) ) {

        // send accept header
        sprintf(response_buffer, "HTTP/1.1 200 OK\r\n\r\n");

        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;



        // send received request + CRLF
        snprintf(response_buffer, BUFFER_SIZE, "%s %s %s\r\n", method, uri, version);

        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;
     

        // send client IP and CRLF
        char *client_ip_address = inet_ntoa(client_address.sin_addr);       // extract ip address A.B.C.D

        snprintf(response_buffer, BUFFER_SIZE, "%s\r\n", client_ip_address);

        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;


        // send port
        snprintf(response_buffer, BUFFER_SIZE, "%d", ntohs(client_address.sin_port));

        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

        // close socket and kill process
        close(s_double);
        exit(1);
    }
\end{lstlisting}

\newpage\subsection{AUTH}

\begin{lstlisting}
// before accessing an existing file it is needed to AUTHENTICATE
if( !auth_value ) {
    
    snprintf(response_buffer, BUFFER_SIZE, "HTTP/1.1 401 UNAUTHORIZED\r\nWWW-Authenticate: Basic realm=\"Users\"\r\nConnection: close\r\n\r\n");

    if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
        perror("write() failed");
        return 1;
    }


    fclose(file);
    close(s_double);

    continue;

}


for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

// extract base64_cred
for(i = 1; auth_value[i] != ' '; i++);
base64_cred = auth_value + i + 1;



snprintf(response_buffer, BUFFER_SIZE, "%s:%s", username, password);

if( strcmp( base64_cred, base64_encode(response_buffer, strlen(response_buffer)))){

    printf("base64_cred = %s (%d)\n", base64_cred, strlen(base64_cred));
    printf("base64_corr = %s\n", base64_encode(response_buffer, strlen(response_buffer)));

    snprintf(response_buffer, BUFFER_SIZE, "HTTP/1.1 401 UNAUTHORIZED\r\nWWW-Authenticate: Basic realm=\"Users\"\r\nConnection: close\r\n\r\n");

    if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
        perror("write() failed");
        return 1;
    }
    
    
    fclose(file);
    close(s_double);

    continue;
}
\end{lstlisting}

\subsubsection{Base64}

\begin{lstlisting}
static const char base64_alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

char* base64_encode(const char* input_array, size_t input_size) {
    // Allocate memory for the output string
    char* output = (char*)malloc(((input_size + 2) / 3 * 4 + 1) * sizeof(char));
    if (output == NULL) {
        return NULL;
    }

    // Perform the Base64 encoding
    size_t output_index = 0;
    for (size_t i = 0; i < input_size; i += 3) {
        // Encode the next 3 bytes
        unsigned char byte1 = (i < input_size) ? input_array[i] : 0;
        unsigned char byte2 = (i + 1 < input_size) ? input_array[i + 1] : 0;
        unsigned char byte3 = (i + 2 < input_size) ? input_array[i + 2] : 0;

        output[output_index++] = base64_alphabet[(byte1 >> 2) & 0x3F];
        output[output_index++] = base64_alphabet[((byte1 & 0x3) << 4) | ((byte2 >> 4) & 0xF)];
        output[output_index++] = base64_alphabet[((byte2 & 0xF) << 2) | ((byte3 >> 6) & 0x3)];
        output[output_index++] = base64_alphabet[byte3 & 0x3F];
    }

    // Handle the case when the input size is not a multiple of 3
    if (input_size % 3 == 1) {
        output[output_index - 2] = '=';
        output[output_index - 1] = '=';
    } else if (input_size % 3 == 2) {
        output[output_index - 1] = '=';
    }

    // Null-terminate the output string
    output[output_index] = '\0';

    return output;
}
\end{lstlisting}

\newpage\subsection{Blacklist}

\begin{lstlisting}
// create link
sprintf(link, "%s%s", host, uri);

printf("%s\n", link);

// open blacklist
FILE * blacklist = fopen(BLACKLIST, "r");
char * blacklist_item;

// retrive link from blacklist.txt if exists
while (fgets(blacklist_buffer, BUFFER_SIZE, blacklist)) {

    // null terminate
    blacklist_buffer[strlen(blacklist_buffer) - 1] = 0;

    // if uri is in the blacklist
    if ( !strncmp(blacklist_buffer, link, strlen(link)) ) {

        if( referer ) {
            printf("NOT NULL: %s\n", referer);
            // parse the referer
            for(i = 0; referer[i] != '/'; i++);
            for(++i; referer[i] != ':'; i++);
            for(++i; referer[i] != '/'; i++);

            snprintf(response_buffer, BUFFER_SIZE, "HTTP/1.1 307 Temporary Redirect\r\nLocation: %s\r\nConnection: close\r\n\r\n", referer + i + 1);

        } else {
            
            printf("NULL: %s\n", referer);

            snprintf(response_buffer, BUFFER_SIZE, "HTTP/1.1 403 Forbidden\r\nConnection:close\r\n\r\n"
                                                    "<html>"
                                                    "<h1>You are not allowed to access in this page because it is blacklisted</h1>"
                                                    "</html>");

        }


        if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
            perror("write() failed");
            return 1;
        }

        for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

        // close socket and kill process
        close(s_double);
        exit(1);

    }

    for(i = 0; i < BUFFER_SIZE; i++) blacklist_buffer[i] = 0;

}
\end{lstlisting}


\newpage\subsection{Cookie}

\begin{lstlisting}
// retrieve cookie value
for(i = 0; i < lines; i++)
    if( !strcmp(headers[i].key, "Cookie") )
        client_cookie_string = headers[i].value;

// if is not null
if( client_cookie_string ) {

    // extract name and value of the Cookie
    client_cookie_name = client_cookie_string;
    for(i = 0; client_cookie_string[i] != '='; i++);
    client_cookie_string[i++] = 0;
    
    if(client_cookie_name)
        client_cookie_value = atoi(client_cookie_string + i);
}
\end{lstlisting}

\begin{lstlisting}
// if the client goes in the contact.html AND (does not have cookie OR the cookie name is incorrect OR the cookie value is incorrect)
if( !strcmp(uri, "/contact.html") && ( !client_cookie_name || strcmp(client_cookie_name, COOKIE_NAME) || client_cookie_value != 1)) {
    
    snprintf(response_buffer, BUFFER_SIZE, "HTTP/1.1 403 Forbidden\r\nConnection:close\r\n\r\n<html><h1>You need to access <a href=\"/index.html\">/index.html</a> before entering this page.</h1></html>");

    write(s_double, response_buffer, strlen(response_buffer));

    for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;

    // close everything
    fclose(file);
    close(s_double);
    exit(1);
}


// if client is in index.html AND (does not have cookie OR the cookie name is incorrect OR the cookie value is incorrect)
if( !strcmp(uri, "/index.html") && (!client_cookie_name || strcmp(client_cookie_name, COOKIE_NAME) || client_cookie_value != 1)) {

    sprintf(response_buffer, "HTTP/1.1 200 OK\r\nSet-Cookie:%s=%d\r\n\r\n", COOKIE_NAME, 1);

} else if (!strcmp(uri, "/contact.html") && !strcmp(client_cookie_name, COOKIE_NAME) && client_cookie_value == 1) {
    
    sprintf(response_buffer, "HTTP/1.1 200 OK\r\nSet-Cookie:%s=%d\r\n\r\n", COOKIE_NAME, 0);

} else {

    sprintf(response_buffer, "HTTP/1.1 200 OK\r\n\r\n");

}

if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
    perror("write() failed");
    return 1;
}

for(i = 0; i < BUFFER_SIZE; i++) response_buffer[i] = 0;
\end{lstlisting}




\newpage\subsection{Chunked}

\begin{lstlisting}
// create response header
sprintf(buffer, "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n");

// write response
if( write(s_double, buffer, strlen(buffer)) == -1 ) {
    perror("write() failed");
    return 1;
}

char chunk_size[20];

while( !feof(file) ){
    
    // read at most 1Kb from the file
    fread(buffer, 1, 1024, file);

    // get first line of the response
    sprintf(chunk_size, "%x\r\n", strlen(buffer));

    // write the first line
    if( write(s_double, chunk_size, strlen(chunk_size)) == -1 ) {
        perror("write() failed");
        return 1;
    }

    // write the chunk
    if( write(s_double, buffer, strlen(buffer)) == -1 ) {
        perror("write() failed");
        return 1;
    }

    // end of the chunk
    if( write(s_double, CRLF, strlen(CRLF)) == -1 ) {
        perror("write() failed");
        return 1;
    }

}

// last chunk
sprintf(buffer, "0\r\n");

// write last chunk
if( write(s_double, buffer, strlen(buffer)) == -1 ) {
        perror("write() failed");
        return 1;
}
\end{lstlisting}


\newpage\subsection{ETag}

\begin{lstlisting}
// get entity tag value by summing the ascii values of each caracter in the file
unsigned long e_tag_value = 0;
char character[1] = {0};

while( !feof(file) ) {
    // read 1 character
    fread(character, 1, 1, file);

    // sums value
    e_tag_value = e_tag_value + (unsigned long) character[0];
}

if( e_tag_request && (e_tag_request == e_tag_value) ) {
    
    printf("\n\n");

    // create header
    sprintf(response_buffer, "HTTP/1.1 304 Not Modified\r\nETag: \"%d\"\r\nConnection: close\r\n\r\n", e_tag_value);

    if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
        perror("write() failed");
        return 1;
    }

    // close file, socket and kill process
    fclose(file);
    close(s_double);
    exit(1);
}

// send accept header
sprintf(response_buffer, "HTTP/1.1 200 OK\r\nETag: \"%d\"\r\n\r\n", e_tag_value);

if( -1 == write(s_double, response_buffer, strlen(response_buffer)) ){
    perror("write() failed");
    return 1;
}

// pointer back
rewind(file);
\end{lstlisting}